# 4. 문제 해결 패턴

생성일: 2021년 12월 18일 오전 1:22

> 이번 챕터에서는 일반적인 문제풀이 패턴에 대해서 학습한다.

---

### 1️⃣  빈도수 세기 패턴

> 🎯 2중으로 중첩된 반복문 보다는, 단일 반복문 두 개를 사용하는 것이 훨씬 좋다.

1. **빈도수 세기 알고리즘 패턴 (전체 코드)**

   ```jsx
   function same(arr1, arr2) {
     if (arr1.length !== arr2.length) {
       return false;
     }
     let frequencyCounter1 = {};
     let frequencyCounter2 = {};
     for (let val of arr1) {
       frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1;
     }
     for (let val of arr2) {
       frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1;
     }
     console.log(frequencyCounter1);
     console.log(frequencyCounter2);
     for (let key in frequencyCounter1) {
       if (!(key ** 2 in frequencyCounter2)) {
         return false;
       }
       if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) {
         return false;
       }
     }
     return true;
   }

   same([1, 2, 3, 2, 5], [9, 1, 4, 4, 11]);
   ```

2. 패턴 분석 (단계별)
   - 두 배열의 길이 비교
     > 만약 두 배열의 길이가 다르다면? → 중복된 값이 있거나, 생략된 값이 있는 것을 의미한다.
     ```jsx
     // 두 배열의 길이가 같지 않다면, false를 반환하고 함수를 종료한다.
     if (arr1.length !== arr2.length) {
       return false;
     }
     ```
   - 객체 생성
     > for문을 활용하여 대상객체와 도구객체 하나씩을 만든다.  
     >  "**_그리고 위에서도 설명했듯, 중첩 반복문 보다는 단일 반복문 여러개가 더 낫다."_**
       <img src="https://user-images.githubusercontent.com/67448481/146584026-a4be474c-dd71-4e6c-b528-bf42e25cf062.png" alt="val" width="300">
       
       ```jsx
       let frequencyCounter1 = {}
       let frequencyCounter2 = {}
       for(let val of arr1){
       	// 아래의 코드는 이러한 결과를 도출한다 => { val : (val or 0) + 1 }
       	// 즉, 해당 값이 존재하면 그 값 +1을 해주고, 없으면 0+1을 해준다.
       	frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1
       }
       for(let val of arr2){
       	frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1        
       }
       
       // 이렇게 하면, 두 개의 도구대상 객체가 생성된다.
       ```

   - 반복문 내에서 도구/대상 비교하기
     > 객체에 대한 반복문에서는 반환값이 value가 아닌, **key가 반환된다.**
     ```jsx
     for (let key in frequencyCounter1) {
       // {key:1} -> {key^2:1}의 구조에서,
       // key^2의 값이 fC2의 키값에 존재하는지 체크하는 조건문
       if (!(key ** 2 in frequencyCounter2)) {
         return false;
       }
       // {key^2 : n}에서 n값이 fC1의 {key: n}에서의 n값과 같은지 같지 않은지 체크
       if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) {
         return false;
       }
     }
     // 이 모든 조건문을 통과하면 => true를 리턴한다.
     ```
3. `for ... in` 과 `for ... of`의 차이?
   - `for ... in` : 객체에서도 사용 가능하다.
   - `for ... of` : 객체에서 사용 불가능하다 (문자열, 배열, Set 등등)
